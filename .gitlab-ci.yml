# 1. Определение этапов (stages)
stages:
  - deploy

# 2. Определение задачи (job) для деплоя
deploy_to_server:
  # Назначаем этап
  stage: deploy
  
  # Указываем, какой Runner должен выполнить эту задачу
  # ТЕГ ДОЛЖЕН СОВПАДАТЬ с тегом, который вы указали при регистрации!
  tags:
    - deploy  
  
  # Список команд, которые будет выполнять Shell Executor
  script:
    - echo "Начинаем процесс деплоя с использованием Docker Compose..."
    
    # ПЕРЕЙТИ В ДИРЕКТОРИЮ ПРОЕКТА: 
    # GitLab Runner по умолчанию клонирует репозиторий в папку /home/gitlab-runner/builds/...
    # Команда ниже переходит в папку с кодом, где должен лежать docker-compose.yml
    - cd $CI_PROJECT_DIR 
    
    # 1. Остановить старые контейнеры, чтобы избежать конфликтов и обновить образы
    - docker compose down --remove-orphans
    
    # 2. Собрать (если нужно) и запустить новые контейнеры в фоновом режиме (-d)
    - docker compose up -d --build
    
    # 3. Подождать для инициализации
    - sleep 15
    
    # 4. Проверить статус (если упадёт - перейдём в after_script)
    - docker compose ps
    - docker compose logs backend
    
    - echo "Деплой завершен успешно!"
  
  # Этот блок выполнится ВСЕГДА, даже если script упал
  after_script:
    - cd $CI_PROJECT_DIR || true
    - echo "=== DEBUGGING INFORMATION ==="
    - echo "=== Container Status ==="
    - docker compose ps || docker ps -a || true
    - echo ""
    - echo "=== Backend Container Logs (last 200 lines) ==="
    - docker compose logs --tail=200 backend || docker logs testops-backend || true
    - echo ""
    - echo "=== Backend Health Check ==="
    - docker inspect testops-backend --format='{{json .State.Health}}' | python3 -m json.tool || true
    - echo ""
    - echo "=== Frontend Logs (last 50 lines) ==="
    - docker compose logs --tail=50 frontend || true
    - echo ""
    - echo "=== All containers ==="
    - docker ps -a || true
    
  # Условие: запускать только при push в ветку main (или master)
  only:
    - main